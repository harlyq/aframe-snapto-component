!function(t){var e={};function o(i){if(e[i])return e[i].exports;var n=e[i]={i:i,l:!1,exports:{}};return t[i].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=t,o.c=e,o.d=function(t,e,i){o.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:i})},o.r=function(t){Object.defineProperty(t,"__esModule",{value:!0})},o.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return o.d(e,"a",e),e},o.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},o.p="",o(o.s=0)}([function(t,e){THREE||console.error("requires three.js"),AFRAME||console.error("requires aframe.io"),AFRAME.registerComponent("snapto",{schema:{type:{default:"hitposition",oneof:"hitposition, hitnormal, gridsnap",description:"align the object to either the position of the hit pointing UP (hitposition), to the hit position with the up in the direction of the normal (hitnormal), or grid position (gridsnap)",parse:t=>t.toLowerCase()},offset:{type:"vec3",description:"offset (in local coordinates) to apply to the node after it has been snapped into place"},grid:{type:"vec3",default:{x:1,y:1,z:1},if:{type:["gridsnap"]},description:"grid spacing, centered on 0,0,0"},objects:{default:"*",if:{type:["hitposition","hitnormal"]},description:"selector for determining which objects for the raycast, by default checks against all other objects in the scene"},rayStart:{default:0,if:{type:["hitposition","hitnormal"]},description:"start point along the 'direction' for the ray from the entities origin, can use -ve values to start behind the entity"},direction:{type:"vec3",default:{x:0,y:-1,z:0},if:{type:["hitposition","hitnormal"]},description:"world direction of the ray for the snap test"},continuous:{default:!1,description:"if true, perform the snap every frame, good for moving objects, but computationally expensive (cannot be changed at runtime)"}},multiple:!1,init:function(){this.snapTo=this.snapTo.bind(this),this.objects=[],this.objectsNeedUpdate=!0,this.raycaster=new THREE.Raycaster,this.origin=(new THREE.Vector3).copy(this.el.object3D.position),this.data.continuous&&(this.tick=this.snapTo)},update:function(t){this.objectsNeedUpdate=!0,Object.getOwnPropertyDescriptor(this,"tick")||(this.el.sceneEl.renderStarted?this.snapTo():this.el.sceneEl.addEventListener("renderstart",this.snapTo))},snapTo:function(){switch(this.data.type){case"hitnormal":case"hitposition":return this.snapToObjects();case"gridsnap":return this.snapToGrid()}},snapToGrid:function(){const t=this.el.object3D,e=t.position,o=this.data.grid,i=this.data.offset;let n=Math.floor(e.x/o.x)*o.x+i.x,r=Math.floor(e.y/o.y)*o.y+i.y,s=Math.floor(e.z/o.z)*o.z+i.z;t.position.set(n,r,s)},snapToObjects:function(){let t=new THREE.Vector3(0,1,0),e=new THREE.Quaternion,o=new THREE.Vector3,i=new THREE.Quaternion,n=new THREE.Vector3,r=new THREE.Vector3,s=new THREE.Vector3,a=new THREE.Euler,c=new THREE.Euler,h=[];return function(){const p=this.data,l=this.el.object3D;if(this.objectsNeedUpdate){this.objectsNeedUpdate=!1;const t=p.objects?this.el.sceneEl.querySelectorAll(p.objects):this.el.sceneEl.children;this.objects.length=0;for(let e=0,o=t.length;e<o;e++){let o=t[e].object3D;o&&o.children&&o.children.length&&this.objects.push(...o.children)}for(let t=0,e=l.children.length;t<e;t++){const e=this.objects.indexOf(l.children[t]);-1!==e&&this.objects.splice(e,1)}}if(0!==this.objects.length&&(r.copy(p.direction).normalize(),s.copy(r).multiplyScalar(p.rayStart).add(this.origin),this.raycaster.set(s,r),h.length=0,(h=this.raycaster.intersectObjects(this.objects,!1,h)).length>0)){const r=h[0];"hitnormal"===p.type&&r.face?(r.object.getWorldQuaternion(e),o.copy(r.face.normal).applyQuaternion(e).normalize(),i.setFromUnitVectors(t,o),a.setFromQuaternion(i,"XZY"),c.copy(l.rotation).reorder("YXZ"),a.y=-c.y,i.setFromEuler(a),n.copy(p.offset).applyQuaternion(i).add(r.point),l.position.set(n.x,n.y,n.z),l.setRotationFromQuaternion(i)):(n.copy(p.offset).add(r.point),l.position.set(n.x,n.y,n.z))}}}()})}]);